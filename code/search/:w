# Day1
[kuangbin专题1：简单搜索](https://vjudge.net/contest/65959#overview)


分类
记录路径: poj3414, poj3984,
两点bfs: poj2150, uva11624,



1. 
**
学习:poj 3278一直过不了，跟网上代码基本一样，然后复制了那段代码，打了一些随机数出来，跑两遍，比较结果后才发现错误
```cpp
int main()
{
    freopen("in","w",stdout);
    for (int i=0;i<100;i++)
    {
        cout << rand()%100000 << " " << rand()%100000 << endl;
    }
}
```
**

2. bfs固定模板   5步+循环(越界+返回+回溯)
注意到要找到每种状态间的变化

3. dfs固定模板   递归深搜


> (dfs一般写为子程序，bfs一般用来找最短路)

4. bfs中step可以存在struct node{}中，也可以直接开数组存，直接开数组存一般是为了保存下访问该点时的路径深度(),例如下面两个'两点bfs'的题，

5. bfs中的Q只是用来过渡的，一个容器存放中间状态而已，真正要的在step
6. 如果只存下地点的位置信息，有下面三种用法
- 
```
struct node{int x,y;}
```
- 
```
queue<pair<int,int>> Q
```
- 
```
struct node{
    int x,y;
    node(){x=x,y=y};
};``


***

## poj 1321 dfs
### 题意:
    给个map，往里面放棋子，问有多少种情况能使得所有棋子放不同行不同列（类似八皇后变形）
### 思路:
    逐行深搜
    回溯的处理要写好，然后记得分成放跟不放这两种情况，基本就是这几个要点
> (dfs一般写为子程序，bfs一般用来找最短路)

```cpp
/*************************************************************************
	> File Name: poj 1321.cpp
	> Author: mazicwong
	> Mail: mazicwong@gmail.com
	> Created Time: 2017年07月16日 星期日 23时46分42秒
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <algorithm>
using namespace std;
const int maxn=10;
char mp[maxn][maxn];//棋盘
bool visit[maxn];//一列是否放过棋子
int n,k;
int ans;//方案数

//k<=n，有两种情况，dfs中分开讨论，记得避免越界
void dfs(int row,int cnt) //逐行深搜，row是当前行，cnt是已经填充的棋子数
{
    if (k==cnt) //判等时保持变化量写右边 :) 习惯
    {
        ans++;
        return;
    }

    if (row>n)  //因为有dfs(row+1,cnt),这里要避免搜索越界，很多搜索都会有
        return;

    for (int j=1;j<=n;j++)
    {//对一行进行深搜
        if (visit[j]==0 && mp[row][j]=='#')
        {
            visit[j]=true; //假设在这里放下棋子，然后再遍历下一行
            dfs(row+1,cnt+1); //
            visit[j]=false; //回溯后，上面的状态已经记录了，还原标记
        }
    }
    dfs(row+1,cnt); //这里是难点，上面已经把放下棋子情况搜了一遍，并且已经回溯了
                    //这里再搜一遍不放棋子的，不要漏掉这种
    return;
}

int main()
{
    freopen("in.txt","r",stdin);
    while(cin>>n>>k && n!=-1)
    {
        ans=0;
        for (int i=1;i<=n;i++)
        {
            for (int j=1;j<=n;j++)
                cin>>mp[i][j];
        }
        memset(visit,0,sizeof(visit));
        dfs(1,0);
        printf("%d\n",ans);
    }
    return 0;
}
```


插一下。。。这题可以用状压做
```cpp
/*************************************************************************
	> File Name: poj 1321 状压dp.cpp
	> Author: mazicwong
	> Mail: mazicwong@gmail.com
	> Created Time: 2017年07月17日 星期一 11时21分28秒
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <algorithm>
using namespace std;
//状压写法
//状态转移：当前行不加棋子，加棋子
//dp[i][j]：i行数，j棋子状态(1有，0无)
const int maxn=10;
int n,k;
char mp[maxn][maxn];
int cnt[1<<maxn];
int dp[maxn][1<<maxn]; //i行数，j加不加棋子

int check(int n)
{
    int ans=0;
    while(n)
    {
        if (n%2)
            ans++;
        n/=2;
    }
    return ans;
}
int main()
{
    //freopen("in.txt","r",stdin);
    for (int i=0;i<(1<<maxn);i++)
        cnt[i]=check(i);
    while(cin>>n>>k && n!=-1)
    {
        memset(dp,0,sizeof(dp));
        for (int i=1;i<=n;i++)
            for (int j=1;j<=n;j++)
                cin>>mp[i][j];
        dp[0][0]=1;
        for (int i=1;i<=n;i++)
        {
            for (int j=0;j<(1<<n);j++)
            {
                if (cnt[j]<=k)
                {
                    dp[i][j]+=dp[i-1][j];  //获取前n-1行的
                    for (int p=1;p<=n;p++) //更新本行
                    {
                        if ( ((1<<(p-1))&j) && mp[i][p]=='#')
                        {
                            dp[i][j]+=dp[i-1][(~(1<<p-1))&j];
                        }
                    }
                }
            }
        }
        int ans=0;
        for (int i=0;i<(1<<n);i++)
            if (cnt[i]==k)
                ans += dp[n][i];
        cout << ans << endl;
    }
    return 0;
}
```



## poj 2251 三维bfs
    变形:六个方向变化
### 题意:
>  3维面，从S到E求最短路

### 思路:
>  3维bfs,只是把平时的4个方向改成6个方向
  学好这种3维方向变化的写法to[6][3]

### 借鉴点:
>  状态更新时to的写法

```cpp
/*************************************************************************
	> File Name: poj 2251.cpp
	> Author: mazicwong
	> Mail: mazicwong@gmail.com
	> Created Time: 2017年07月17日 星期一 16时07分08秒
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <algorithm>
#include <queue>

using namespace std;
const int maxn = 30+5;
char mp[maxn][maxn][maxn];
int vis[maxn][maxn][maxn];
int sx,sy,sz;
int ex,ey,ez;
int k,n,m; //level,row,column;
int to[6][3] = {
    {0,0,1},{0,0,-1},
    {0,1,0},{0,-1,0},
    {1,0,0},{-1,0,0}
};

struct node{
    int x,y,z;
    int step;
};

int check(int x,int y,int z)
{
    if (x<0 || y<0 || z<0 || x>=k || y>=n || z>=m)
        return 1;
    else if (mp[x][y][z] == '#')
        return 1;
    else if (vis[x][y][z])
        return 1;
    return 0;
}

int bfs()
{
    node a,next;
    queue<node> Q;
    a.x=sx, a.y=sy, a.z=sz;
    a.step=0;
    vis[sx][sy][sz]=1;
    Q.push(a);
    while(!Q.empty())
    {
        a = Q.front();
        Q.pop();
        if (a.x==ex && a.y==ey && a.z==ez)
            return a.step;
        for (int i=0;i<6;i++)
        {
            next = a;
            next.x = a.x+to[i][0];
            next.y = a.y+to[i][1];
            next.z = a.z+to[i][2];
            if (check(next.x,next.y,next.z))
                continue;
            vis[next.x][next.y][next.z]=1;
            next.step = a.step+1;
            Q.push(next);
        }
    }
    return 0;
}

int main()
{
    freopen("in.txt","r",stdin);
    while(cin>>k>>n>>m && k!=0)
    {
        for (int i=0;i<k;i++)
        {
            for (int j=0;j<n;j++)
            {
                scanf("%s",mp[i][j]);
                for (int tt=0;tt<m;tt++)
                {
                    if (mp[i][j][tt] == 'S')
                    {
                        sx=i,sy=j,sz=tt;
                    }
                    else if (mp[i][j][tt] == 'E')
                    {
                        ex=i,ey=j,ez=tt;
                    }
                }
            }
        }
        memset(vis,0,sizeof(vis));
        int ans = bfs();
        if (ans)
            printf("Escaped in %d minute(s).\n",ans);
        else printf("Trapped!\n");

    }

    return 0;
}
```

***

## poj 3278 一维bfs (经典格式了)
   变形:三种操作,用for做个判断
### 题意:
> 一条线，从n出发到达k点，三种操作
  1.x+1
  2.x-1
  3.x*2
  问最短到达次数

### 思路:
> 1. 一维bfs求最短路,固定套路(5步+while)
  2. 开始以为这道题应该不用bfs也能做，前期操作一直递增，然后到临界点的时候判断一下取最优解就可以;
  不过，也有可能是先减少然后翻倍这样反而获得最优解,所以最后还是老老实实写bfs

> (dfs一般写为子程序，bfs一般用来找最短路)

### 注意:这道题WA了无数次。最后问题出在有可能没有解，此时返回一个负数都可以通过，正数则不行，在bfs最后面补了一个return -1;然后通过了。有点坑

```cpp
/*************************************************************************
	> File Name: poj 3278.cpp
	> Author: mazicwong
	> Mail: mazicwong@gmail.com
	> Created Time: 2017年07月17日 星期一 18时35分10秒
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <algorithm>
#include <queue>
using namespace std;
const int maxn = 1e5+5;
int n,k;
bool vis[maxn];
struct node{
    int cur;
    int step;
};
int bfs()
{
    node a,next;
    queue<node> Q;
    a.cur=n, a.step=0;
    vis[a.cur]=1;
    Q.push(a);
    while(!Q.empty())
    {
        a = Q.front();
        Q.pop();
        for (int i=0;i<3;i++)
        {
            if (i==0)
            {
                next.cur=a.cur+1;
                next.step=a.step+1;
            }
            else if (i==1)
            {
                next.cur=a.cur-1;
                next.step=a.step+1;
            }
            else if (i==2)
            {
                next.cur=(a.cur<<1);
                next.step=a.step+1;
            }

            if (next.cur<0 || next.cur>=maxn) //排除出界情况(可以呼略的剪枝)
                continue;
            if (vis[next.cur])
                continue;
            if (next.cur==k)
                return next.step;
            vis[next.cur]=1;
            Q.push(next);
        }
    }
    return -1; //?????
}

int main()
{
    freopen("in","r",stdin);
    freopen("out","w",stdout);
    while(cin>>n>>k)
    {
        memset(vis,0,sizeof(vis));
        if (n>=k)
            cout << n-k << endl;
        else
            cout << bfs() << endl;
    }
    return 0;
}
```




***

## poj 3279 状压
### 题意:
>  一片矩形地，每个块的属性是0和1,一只奶牛可以翻转每个块，她落在某个位置，则该位置及四周均翻转一次
  求最少步数使得上面都变为0

### 思路: 一开始没想出来这题怎么是搜索，看了网上的题解。dalao们真强
>  1. 第一行2^n种情况遍历一遍，然后推下去每一行，都使得上一行为0,最后根据尾行是否全0来判断能否成立。
      感觉有点像状压。。而且数据量也可以接受指数级。。搜了一下，真有状压解法。继续学习。
   2. 直接状压解法，存下2^n种情况，对每一种solve()一遍，然后找出最小的次数(跟法1其实差不多?)
   > 其实这里传入状态st进行处理，可以把st看成是第一行再上面一行的状态，这样可以容易理解点。(代码实现起来会更方面，mp[0][1-m]存st的状态，取出状态用((st>>j)&1) )


## poj 1426 两个方向的dfs && 打表
### 题意:
>  找一个数m,满足是n的倍数且其十进制均由0和1组成

### 思路:
>  1. 因为都是0,1,所以从1开始，每次两种变形，(t*10)和(t*10+1)，然后再判断是否满足，注意不要越界(超过unsigned long long 就回溯就行了，肯定有解的)
   2. 跟法1意义，不过深搜暴力后打了个表过啦，不过要注意的是，数组很大，开的时候用`unsigned long long a[200];` 在输出的时候应该用`printf("%I64llu",a[n]);` 一开始写成%I64ull过不了.


## poj 3126 经典bfs+素数筛选(类似poj3278,经典bfs) 
   变形:每次4个数，每个数共有9种变化
### 题意:
>  给两个数字，要求从一个变到另一个，每次只能改变一个数字，且每次变更完后都是素数，求最小需要改变多少次

### 思路:
>  1. 很明显，这题本质上也可以看成是最短路问题,直接搜索出答案




## poj 3087 bfs+模拟
   变形:只有一个方向的变化(其实这种不应该归入bfs，因为每次变化只朝着一个方向，直接暴力模拟题而已,可以参考知乎上关于 **'暴力模拟'&‘贪心’&‘dp'区别** 的最高赞答案)

### 题意:
>  给s1,s2,ee串,长度为c和2c，然后把s1,s2交错叠放(s2最下面一张放最下面),的到新s12,再将s12下面C个字符赋给s1,上面c个给s2,重复直到s12为ee,求最少次数

### 思路:
>  很明显的bfs,直接模拟，node中存的step是最终答案，然后还要判断该状态是否出现过(用`map<string,int> vis;`判断,相当于之前的vis[maxn])，如果出现过，就直接return -1了



## poj 3414 bfs+路径输出(不用队列，改用数组进行模拟)
   变形:六个方向
### 题意:
>  两杯水，三种操作，’倒满‘&&’倒空‘&&’a倒入b中直接a空或b满‘
   找最少次数使得有一个水杯恰好剩下C

### 思路:
>  每一种状态有六个状态可以到达，关键在于输出路径，直接bfs搜索
   分别用六个数字表示6种对应状态，然后存储数字，方便输出



## fzu 2150 两个起点的bfs
   变形:四个方向
### 题意:
>  矩形框内有某些草地，要求同时在两个地方点火(两地方可以重复)，目的是烧完所有草地，问最短时间，不能烧完输出-1

### 思路:
>   1. 第一眼:找连通块
    >  >2:退出
    >  =2:各自遍历,在已知连通块内求下深度
    >  =1:同一连通块内搞
    2. 网上大部分解法都是暴力找每两个草堆，找出bfs需要的时间,再判断搞定这两个草堆是否已经全部搞定，因为数据量就10,这种方法完全可行，
 


## uva 11624 两个起点的bfs
   变形:四个方向
### 题意:
>  地图内一个点着火，火跟人速度一样，人需要避开火和障碍物到达边缘，问最短路

### 思路:
>   1. 第一眼:找连通块

>注意:单起点一般用vis记录访问过的点，然后node中记录step
两起点的话，一般用step1[],step2[]分别记录两个人抵达点时的深度



## poj 3984  bfs+记录路径
   变形:4个方向
### 题意:
>  矩形,左上角到右下角的最短路,并输出路径

### 思路:
>  bfs求最短路，用pre记录每一个状态之前的状态，然后输出路径  


## hdu 1241 dfs求连通块裸题
   变形:8个方向
### 题意:
>  给一片矩形地，找连通块数,horizontally,vertically,diagonally都叫连通

### 思路:
>  对所有点做一遍8个方向的dfs,注意访问过就变为石头



## hdu 1495 求连通块裸题
   变形:6个方向
### 题意:
>  给一个可乐容量s，两个杯子容量a,b，目的是要用最少次数平分这个可乐

### 思路:
>  有明确的初始态和终止态，和六个变化的方向，明显bfs
   初始(s,a,b)= (s,0,0)
   终止(s,a,b)= (s>>1,s>>1,0)  (假定a为大号杯)
   六个方向:  s->a  s->b  a->b  a->s  b-a  b->s


## hdu 2612 求连通块裸题
   变形:6个方向
### 题意:
>  两人走迷宫，有很多个出口，要求到达同一个出口会面，且总花费时间最少

### 思路:
>  对两个人分别bfs，找出其到每一点的时间，然后枚举所有出口，找到最短时间







## hdu 1043 八数码问题-bfs
   变形:6个方向
### 题意:
> 经典八数码，走成1-8x最少几步

### 思路:
> 共有9!种状态(9个数全排列就是了),然后用123456780倒推所有能走到该状态的状态
  因为有多组数据,所以没办法在线bfs(会重复多次),则采用计算出输入状态的**康托逆展开**的hash值,
  就可以直接输出对应的路径
  






## hdu 3567 求连通块裸题
   变形:6个方向
### 题意:
> 

### 思路:
>



