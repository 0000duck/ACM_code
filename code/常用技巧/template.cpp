1.离散化
2.尺取法
3.vim配置
4.java


离散化:就是将n个数字和1~n对应起来
使用STL算法离散化：
思路：先排序，再删除重复元素，然后就是索引元素离散化后对应的值。

/*
 * eg:
 * 一组数据:1,4,1000,100000;直接开线段树很浪费,则先离散化
 *
 * 离散化前 a[i]: 1,    4,   1000, 100000,
 * 离散化后 a[i]: 1,    2,    3,    4,
 *               a[0], a[1], a[2], a[3],
 */

const int maxn = 100;
int n=6;
int a[maxn];//离散化后的数组a
void lisan(int *arr)//传入数组arr[0..n-1],返回a[0..n-1]
{
    for (int i=0;i<n;i++) a[i]=arr[i];

    sort(a,a+n);
    int size = unique(a,a+n)-a; //size是离散化后元素个数
    for (int i=0;i<n;i++)
        a[i] = lower_bound(a,a+size,arr[i])-a+1;
}

int main()
{
    int qq[20]={0,1,4,6,7,800,1000};
    lisan(qq);
    for (int i=0;i<=n;i++)
        cout << "i:" << i << "   a:[" << i << "]: "<<  a[i] << endl;

    return 0;
}



--------------------------------------------------------------------
尺取法
像尺子一样取一段,设置左右端点,不断右移右端点和左端点,直到找到最优解  

挑战程序竞赛 P146  
挑战书上面的话说，尺取法通常是对数组保存一对下标，即所选取的区间的左右端点，然后根据实际情况不断地推进区间左右端点以得出答案。  

作用:尺取法是一种高效的枚举区间的方法(数据量大时比暴力枚举高效很多)  

应用：(优化枚举区间效率)  
1. 求有一定限制的区间个数或最短的区间等等  
2. 最短的覆盖所有点的子序列 poj3320  

模板如下:四步
int chiqu()
{
    int ans = INF;
    int s=0,t=0,sum=0;//左右端点和前缀和
    while(1)
    {
        while(t<n && sum<S)
            sum += a[t++];//右端点右移
        if (sum<S) break;
        ans = min(ans,t-s);
        sum -= a[s++];//左端点右移
    }
    if (ans == INF) ans=0;
    return ans;
}




***
### poj3061

题意：给定一个序列，找出最短的子序列长度，使得其和大于或等于S。  

思路：当区间和小于S时右端点向右移动，和大于等于S时，左端点向右移动以进一步找到最短的区间，如果右端点移动到区间末尾其和还不大于等于S.结束枚举  




***
### poj3320

题意:一本书有n页，每一页都一个知识点，求去最少的连续页数覆盖所有的知识点。  

思路:一样,右端点移动到满足的位置,此时,如果该区间的子区间满足条件,左端点移动,使得子区间更短(用map和set方便处理数据)  





***
### hdu6103

[参考](http://blog.csdn.net/archger/article/details/77073334)  

题意:  
给出字符串s，寻找其两个长度相同且不重叠的子串，使得两个字符串`每位的ascii差值(一个从前往后,一个从后往前)`之和不大于m，且字符串长度最长。  

思路:  
这是第六次多校的题目,直接暴力过不掉,复杂度O(n^2),刚好处理`区间最优子序列`可以用尺取法,节省枚举所有区间的时间;  
因为字符串的长度为5000，所以可以枚举两个子串的对称轴，预处理出一个`num[]`数组,表示对称轴左右元素的ascii差值;然后对其区间进行尺取法，这样只需要o(n^2)的复杂度即可  





***
### hdu6205(2017沈阳网络赛最后一题..尺取)
题意:  
给`a[]`和`b[]`两串,`del[]=a[]-b[]`,现在要将`del[]`的前几项放到后面,使得从前面往后取直到和为负数,要让这个和能取到最大

思路:  
显然尺取吧..把`del[]`翻成两段然后直接暴力太慢了..而且这题可以尺取..关键注意的地方是输入数据很大,scanf也会T掉,要用fastIO,学习了

