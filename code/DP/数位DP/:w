#include <bits/stdc++.h>
using namespace std;
const int mod = 1000000007;
const int maxn = 1e3+5;
//dp[pos][sta]: 第pos位,状态为sta时满足的个数
//n = 156
//digit = {6 5 1}
//dfs(2,true,true)
int dp[1005][6];
//state
//1: 2
//2: 2,3
//3: 2,3,0
//4: 2,3,0,1
//5: 2,0
//6: 2,0,1

int digit[maxn];
int next_state(int now,int i)
{
    if(now==1)
    {
        switch(i)
        {
            case 0: return 5;break;
            case 1: return -1;break;
            case 2: return 1;break;
            case 3: return 2;break;
        }
    }
    else if(now==2)
    {
        switch(i)
        {
            case 0: return 3;break;
            case 1: return -1;break;
            case 2: return -1;break;
            case 3: return 2;break;
        }
    }
    else if(now==3)
    {
        switch(i)
        {
            case 0: return 3;break;
            case 1: return 4;break;
            case 2: return -1;break;
            case 3: return 3;break;
        }
    }
    else if(now==4)
    {
        switch(i)
        {
            case 0: return -1;break;
            case 1: return 4;break;
            case 2: return -1;break;
            case 3: return 4;break;
        }
    }
    else if(now==5)
    {
        switch(i)
        {
            case 0: return 5;break;
            case 1: return 6;break;
            case 2: return 5;break;
            case 3: return 3;break;
        }
    }
    else if(now==6)
    {
        switch(i)
        {
            case 0: return -1;break;
            case 1: return 6;break;
            case 2: return 6;break;
            case 3: return 4;break;
        }
    }
    return -1;
}


3
1
3 2
3 1
3 1 0
3 2 1 0
3 2 1
//state 0>1, 2>3
//1: 0001
//2: 2
//3: 2,3,0
//4: 2,3,0,1
//5: 
//15:1111



int vis[5];
//debug点: 这个串反过来了,2是最后一个??
int dfs(int pos,int state,bool lead,bool limit)
{
    if(pos==-1)
    {
        if(vis[0] && vis[2] && lead)
            return 1;
        else return 0;
    }
    if(!limit && dp[pos][state]!=-1) return dp[pos][state];
    int up = limit?digit[pos]:3;
    int res=0;
    //0-1  2-3
    for(int i=0;i<=3;i++)
    {
        if(vis[2]&&vis[0])
        {
            res += dfs(pos-1,true,lead&&i==0,limit&&i==digit[pos]);
        }
        
    }
}

int main()
{
    int n;cin>>n;
    memset(dp,-1,sizeof(dp));
    for(int i=0;i<n;i++)digit[i]=4;
    digit[n-1]=2;
    //n=3 // 2,*,*
    //digit={4,4,2}
    printf("%d",dfs(n-2,1,true,true));
    return 0;
}
